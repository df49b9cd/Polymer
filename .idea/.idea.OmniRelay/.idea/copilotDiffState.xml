<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/samples/DistributedDemo/Gateway/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/samples/DistributedDemo/Gateway/Program.cs" />
              <option name="originalContent" value="using DistributedDemo.Inventory.Protos;&#10;using DistributedDemo.Shared.Contracts;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Microsoft.Extensions.Logging;&#10;using OmniRelay.Configuration;&#10;using OmniRelay.Core;&#10;using OmniRelay.Core.Clients;&#10;using OmniRelay.Core.Transport;&#10;using OmniRelay.Dispatcher;&#10;using OmniRelay.Errors;&#10;using static Hugo.Go;&#10;using OmniDispatcher = OmniRelay.Dispatcher.Dispatcher;&#10;&#10;namespace DistributedDemo.Gateway;&#10;&#10;public static class Program&#10;{&#10;    public static async Task Main(string[] args)&#10;    {&#10;        var host = Host.CreateDefaultBuilder(args)&#10;            .ConfigureAppConfiguration((context, configuration) =&gt;&#10;            {&#10;                // Resolve appsettings.json relative to the executing assembly/output folder so the app works&#10;                // whether started from the project directory, solution root, or published container.&#10;                var settingsPath = Path.Combine(AppContext.BaseDirectory, &quot;appsettings.json&quot;);&#10;                configuration.AddJsonFile(settingsPath, optional: false, reloadOnChange: true);&#10;                configuration.AddEnvironmentVariables(prefix: &quot;DDEMO_&quot;);&#10;            })&#10;            .ConfigureLogging(logging =&gt;&#10;            {&#10;                logging.ClearProviders();&#10;                logging.AddConsole();&#10;            })&#10;            .ConfigureServices((context, services) =&gt;&#10;            {&#10;                // Diagnostic: print configured inbound URLs&#10;                try&#10;                {&#10;                    var options = new OmniRelay.Configuration.Models.OmniRelayConfigurationOptions();&#10;                    context.Configuration.GetSection(&quot;omnirelay&quot;).Bind(options);&#10;                    var httpUrls = options.Inbounds?.Http?.SelectMany(h =&gt; h?.Urls ?? Array.Empty&lt;string&gt;())?.ToArray() ?? Array.Empty&lt;string&gt;();&#10;                    var grpcUrls = options.Inbounds?.Grpc?.SelectMany(g =&gt; g?.Urls ?? Array.Empty&lt;string&gt;())?.ToArray() ?? Array.Empty&lt;string&gt;();&#10;                    Console.WriteLine($&quot;[GatewayStartup] HTTP Inbounds: {string.Join(&quot;, &quot;, httpUrls)} | gRPC Inbounds: {string.Join(&quot;, &quot;, grpcUrls)}&quot;);&#10;                    var logger = services.BuildServiceProvider().GetService&lt;ILoggerFactory&gt;()?.CreateLogger(&quot;GatewayStartup&quot;);&#10;                    logger?.LogInformation(&quot;Configured inbound URLs - HTTP: {HttpUrls}; gRPC: {GrpcUrls}&quot;, string.Join(&quot;, &quot;, httpUrls), string.Join(&quot;, &quot;, grpcUrls));&#10;                }&#10;                catch&#10;                {&#10;                    // ignore logging failures&#10;                }&#10;&#10;                services.AddOmniRelayDispatcher(context.Configuration.GetSection(&quot;omnirelay&quot;));&#10;                services.AddSingleton&lt;CheckoutWorkflow&gt;();&#10;                services.AddHostedService&lt;GatewayRegistrationHostedService&gt;();&#10;            })&#10;            .Build();&#10;&#10;        await host.RunAsync().ConfigureAwait(false);&#10;    }&#10;}&#10;&#10;internal sealed class GatewayRegistrationHostedService : IHostedService&#10;{&#10;    private readonly OmniDispatcher _dispatcher;&#10;    private readonly CheckoutWorkflow _workflow;&#10;    private readonly ILogger&lt;GatewayRegistrationHostedService&gt; _logger;&#10;&#10;    public GatewayRegistrationHostedService(&#10;        OmniDispatcher dispatcher,&#10;        CheckoutWorkflow workflow,&#10;        ILogger&lt;GatewayRegistrationHostedService&gt; logger)&#10;    {&#10;        _dispatcher = dispatcher;&#10;        _workflow = workflow;&#10;        _logger = logger;&#10;    }&#10;&#10;    public Task StartAsync(CancellationToken cancellationToken)&#10;    {&#10;        RegisterProcedures();&#10;        _logger.LogInformation(&quot;Gateway dispatcher '{Service}' registered checkout procedures.&quot;, _dispatcher.ServiceName);&#10;        return Task.CompletedTask;&#10;    }&#10;&#10;    public Task StopAsync(CancellationToken cancellationToken) =&gt; Task.CompletedTask;&#10;&#10;    private void RegisterProcedures()&#10;    {&#10;        _dispatcher.RegisterJsonUnary&lt;CheckoutRequest, CheckoutResponse&gt;(&#10;            &quot;checkout::create&quot;,&#10;            async (context, request) =&gt;&#10;            {&#10;                var response = await _workflow.ExecuteAsync(request, context.CancellationToken).ConfigureAwait(false);&#10;                return response;&#10;            },&#10;            configureProcedure: builder =&gt;&#10;            {&#10;                builder.AddAliases([&quot;checkout::submit&quot;]);&#10;            });&#10;&#10;        // Lightweight ping using raw JSON codec for quick smoke testing.&#10;        var pingCodec = new JsonCodec&lt;CheckoutRequest, CheckoutResponse&gt;();&#10;        _dispatcher.RegisterUnary(&quot;checkout::echo&quot;, builder =&gt;&#10;        {&#10;            builder.WithEncoding(pingCodec.Encoding);&#10;            builder.Handle(async (request, cancellationToken) =&gt;&#10;            {&#10;                var decode = pingCodec.DecodeRequest(request.Body, request.Meta);&#10;                if (decode.IsFailure)&#10;                {&#10;                    return Err&lt;Response&lt;ReadOnlyMemory&lt;byte&gt;&gt;&gt;(decode.Error!);&#10;                }&#10;&#10;                var requestPayload = decode.Value;&#10;                var responsePayload = new CheckoutResponse(&#10;                    requestPayload.OrderId,&#10;                    Reserved: true,&#10;                    ConfirmationId: &quot;echo&quot;,&#10;                    Message: &quot;echo&quot;);&#10;&#10;                var responseMeta = new ResponseMeta(encoding: pingCodec.Encoding);&#10;                var encode = pingCodec.EncodeResponse(responsePayload, responseMeta);&#10;                if (encode.IsFailure)&#10;                {&#10;                    return Err&lt;Response&lt;ReadOnlyMemory&lt;byte&gt;&gt;&gt;(encode.Error!);&#10;                }&#10;&#10;                return Ok(Response&lt;ReadOnlyMemory&lt;byte&gt;&gt;.Create(new ReadOnlyMemory&lt;byte&gt;(encode.Value), responseMeta));&#10;            });&#10;        });&#10;    }&#10;}&#10;&#10;internal sealed class CheckoutWorkflow&#10;{&#10;    private readonly UnaryClient&lt;ReserveSkuRequest, ReserveSkuResponse&gt; _inventoryClient;&#10;    private readonly OnewayClient&lt;AuditRecord&gt; _auditClient;&#10;    private readonly JsonCodec&lt;AuditRecord, object&gt; _auditCodec;&#10;    private readonly string _inventoryEncoding;&#10;    private readonly ILogger&lt;CheckoutWorkflow&gt; _logger;&#10;&#10;    public CheckoutWorkflow(OmniDispatcher dispatcher, ILogger&lt;CheckoutWorkflow&gt; logger)&#10;    {&#10;        _logger = logger;&#10;&#10;        var inventoryCodec = new ProtobufCodec&lt;ReserveSkuRequest, ReserveSkuResponse&gt;();&#10;        dispatcher.Codecs.RegisterOutbound(&#10;            &quot;inventory&quot;,&#10;            &quot;inventory::reserve&quot;,&#10;            ProcedureKind.Unary,&#10;            inventoryCodec);&#10;        _inventoryClient = dispatcher.CreateUnaryClient(&quot;inventory&quot;, inventoryCodec);&#10;        _inventoryEncoding = inventoryCodec.Encoding;&#10;&#10;        _auditCodec = new JsonCodec&lt;AuditRecord, object&gt;();&#10;        dispatcher.Codecs.RegisterOutbound(&#10;            &quot;audit&quot;,&#10;            &quot;audit::record&quot;,&#10;            ProcedureKind.Oneway,&#10;            _auditCodec);&#10;        _auditClient = dispatcher.CreateOnewayClient(&quot;audit&quot;, _auditCodec);&#10;    }&#10;&#10;    public async ValueTask&lt;CheckoutResponse&gt; ExecuteAsync(CheckoutRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var reserveRequest = new ReserveSkuRequest&#10;        {&#10;            Sku = request.Sku,&#10;            Quantity = request.Quantity,&#10;            CorrelationId = request.OrderId&#10;        };&#10;&#10;        var inventoryMeta = new RequestMeta(&#10;            service: &quot;inventory&quot;,&#10;            procedure: &quot;inventory::reserve&quot;,&#10;            caller: &quot;gateway.checkout&quot;,&#10;            encoding: _inventoryEncoding);&#10;&#10;        var inventoryCall = await _inventoryClient.CallAsync(&#10;            new Request&lt;ReserveSkuRequest&gt;(inventoryMeta, reserveRequest),&#10;            cancellationToken).ConfigureAwait(false);&#10;&#10;        if (inventoryCall.IsFailure)&#10;        {&#10;            _logger.LogWarning(&#10;                &quot;Inventory reserve failed for {OrderId}: {Message}&quot;,&#10;                request.OrderId,&#10;                inventoryCall.Error?.Message ?? &quot;unknown&quot;);&#10;&#10;            await PublishAuditAsync(&#10;                request.OrderId,&#10;                &quot;inventory.error&quot;,&#10;                inventoryCall.Error?.Message ?? &quot;inventory call failed&quot;,&#10;                cancellationToken).ConfigureAwait(false);&#10;&#10;            return new CheckoutResponse(&#10;                request.OrderId,&#10;                false,&#10;                ConfirmationId: string.Empty,&#10;                Message: inventoryCall.Error?.Message ?? &quot;Inventory error&quot;);&#10;        }&#10;&#10;        var reserveResponse = inventoryCall.Value.Body;&#10;        var message = reserveResponse.Success&#10;            ? $&quot;Reserved {request.Quantity} units of {request.Sku}&quot;&#10;            : string.IsNullOrWhiteSpace(reserveResponse.Message)&#10;                ? &quot;Inventory declined reservation.&quot;&#10;                : reserveResponse.Message;&#10;&#10;        await PublishAuditAsync(&#10;            request.OrderId,&#10;            reserveResponse.Success ? &quot;inventory.success&quot; : &quot;inventory.reject&quot;,&#10;            message,&#10;            cancellationToken).ConfigureAwait(false);&#10;&#10;        return new CheckoutResponse(&#10;            request.OrderId,&#10;            reserveResponse.Success,&#10;            reserveResponse.ConfirmationId,&#10;            message);&#10;    }&#10;&#10;    private async ValueTask PublishAuditAsync(string orderId, string eventType, string details, CancellationToken cancellationToken)&#10;    {&#10;        var meta = new RequestMeta(&#10;            service: &quot;audit&quot;,&#10;            procedure: &quot;audit::record&quot;,&#10;            caller: &quot;gateway.checkout&quot;,&#10;            encoding: _auditCodec.Encoding);&#10;&#10;        var record = new AuditRecord(orderId, eventType, details, DateTimeOffset.UtcNow);&#10;        var ack = await _auditClient.CallAsync(new Request&lt;AuditRecord&gt;(meta, record), cancellationToken).ConfigureAwait(false);&#10;        if (ack.IsFailure)&#10;        {&#10;            _logger.LogWarning(&quot;Audit publishing failed for {OrderId}: {Message}&quot;, orderId, ack.Error?.Message ?? &quot;unknown&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using DistributedDemo.Inventory.Protos;&#10;using DistributedDemo.Shared.Contracts;&#10;using Microsoft.Extensions.Configuration;&#10;using Microsoft.Extensions.DependencyInjection;&#10;using Microsoft.Extensions.Hosting;&#10;using Microsoft.Extensions.Logging;&#10;using OmniRelay.Configuration;&#10;using OmniRelay.Core;&#10;using OmniRelay.Core.Clients;&#10;using OmniRelay.Core.Transport;&#10;using OmniRelay.Dispatcher;&#10;using OmniRelay.Errors;&#10;using static Hugo.Go;&#10;using OmniDispatcher = OmniRelay.Dispatcher.Dispatcher;&#10;&#10;namespace DistributedDemo.Gateway;&#10;&#10;public static class Program&#10;{&#10;    public static async Task Main(string[] args)&#10;    {&#10;        var host = Host.CreateDefaultBuilder(args)&#10;            .ConfigureAppConfiguration((context, configuration) =&gt;&#10;            {&#10;                // Resolve appsettings.json relative to the executing assembly/output folder so the app works&#10;                // whether started from the project directory, solution root, or published container.&#10;                var settingsPath = Path.Combine(AppContext.BaseDirectory, &quot;appsettings.json&quot;);&#10;                configuration.AddJsonFile(settingsPath, optional: false, reloadOnChange: true);&#10;                configuration.AddEnvironmentVariables(prefix: &quot;DDEMO_&quot;);&#10;            })&#10;            .ConfigureLogging(logging =&gt;&#10;            {&#10;                logging.ClearProviders();&#10;                logging.AddConsole();&#10;            })&#10;            .ConfigureServices((context, services) =&gt;&#10;            {&#10;                // Diagnostic: print configured inbound URLs&#10;                try&#10;                {&#10;                    var options = new OmniRelay.Configuration.Models.OmniRelayConfigurationOptions();&#10;                    context.Configuration.GetSection(&quot;omnirelay&quot;).Bind(options);&#10;                    var httpUrls = options.Inbounds?.Http?.SelectMany(h =&gt; h?.Urls ?? Array.Empty&lt;string&gt;())?.ToArray() ?? Array.Empty&lt;string&gt;();&#10;                    var grpcUrls = options.Inbounds?.Grpc?.SelectMany(g =&gt; g?.Urls ?? Array.Empty&lt;string&gt;())?.ToArray() ?? Array.Empty&lt;string&gt;();&#10;                    Console.WriteLine($&quot;[GatewayStartup] HTTP Inbounds: {string.Join(&quot;, &quot;, httpUrls)} | gRPC Inbounds: {string.Join(&quot;, &quot;, grpcUrls)}&quot;);&#10;                    var logger = services.BuildServiceProvider().GetService&lt;ILoggerFactory&gt;()?.CreateLogger(&quot;GatewayStartup&quot;);&#10;                    logger?.LogInformation(&quot;Configured inbound URLs - HTTP: {HttpUrls}; gRPC: {GrpcUrls}&quot;, string.Join(&quot;, &quot;, httpUrls), string.Join(&quot;, &quot;, grpcUrls));&#10;                }&#10;                catch&#10;                {&#10;                    // ignore logging failures&#10;                }&#10;&#10;                services.AddOmniRelayDispatcher(context.Configuration.GetSection(&quot;omnirelay&quot;));&#10;                services.AddSingleton&lt;CheckoutWorkflow&gt;();&#10;                services.AddHostedService&lt;GatewayRegistrationHostedService&gt;();&#10;            })&#10;            .Build();&#10;&#10;        await host.RunAsync().ConfigureAwait(false);&#10;    }&#10;}&#10;&#10;internal sealed class GatewayRegistrationHostedService : IHostedService&#10;{&#10;    private readonly OmniDispatcher _dispatcher;&#10;    private readonly CheckoutWorkflow _workflow;&#10;    private readonly ILogger&lt;GatewayRegistrationHostedService&gt; _logger;&#10;&#10;    public GatewayRegistrationHostedService(&#10;        OmniDispatcher dispatcher,&#10;        CheckoutWorkflow workflow,&#10;        ILogger&lt;GatewayRegistrationHostedService&gt; logger)&#10;    {&#10;        _dispatcher = dispatcher;&#10;        _workflow = workflow;&#10;        _logger = logger;&#10;    }&#10;&#10;    public Task StartAsync(CancellationToken cancellationToken)&#10;    {&#10;        RegisterProcedures();&#10;        _logger.LogInformation(&quot;Gateway dispatcher '{Service}' registered checkout procedures.&quot;, _dispatcher.ServiceName);&#10;        return Task.CompletedTask;&#10;    }&#10;&#10;    public Task StopAsync(CancellationToken cancellationToken) =&gt; Task.CompletedTask;&#10;&#10;    private void RegisterProcedures()&#10;    {&#10;        _dispatcher.RegisterJsonUnary&lt;CheckoutRequest, CheckoutResponse&gt;(&#10;            &quot;checkout::create&quot;,&#10;            async (context, request) =&gt;&#10;            {&#10;                var response = await _workflow.ExecuteAsync(request, context.CancellationToken).ConfigureAwait(false);&#10;                return response;&#10;            },&#10;            configureProcedure: builder =&gt;&#10;            {&#10;                builder.AddAliases([&quot;checkout::submit&quot;]);&#10;            });&#10;&#10;        // Lightweight ping using raw JSON codec for quick smoke testing.&#10;        var pingCodec = new JsonCodec&lt;CheckoutRequest, CheckoutResponse&gt;();&#10;        _dispatcher.RegisterUnary(&quot;checkout::echo&quot;, builder =&gt;&#10;        {&#10;            builder.WithEncoding(pingCodec.Encoding);&#10;            builder.Handle(async (request, cancellationToken) =&gt;&#10;            {&#10;                var decode = pingCodec.DecodeRequest(request.Body, request.Meta);&#10;                if (decode.IsFailure)&#10;                {&#10;                    return Err&lt;Response&lt;ReadOnlyMemory&lt;byte&gt;&gt;&gt;(decode.Error!);&#10;                }&#10;&#10;                var requestPayload = decode.Value;&#10;                var responsePayload = new CheckoutResponse(&#10;                    requestPayload.OrderId,&#10;                    Reserved: true,&#10;                    ConfirmationId: &quot;echo&quot;,&#10;                    Message: &quot;echo&quot;);&#10;&#10;                var responseMeta = new ResponseMeta(encoding: pingCodec.Encoding);&#10;                var encode = pingCodec.EncodeResponse(responsePayload, responseMeta);&#10;                if (encode.IsFailure)&#10;                {&#10;                    return Err&lt;Response&lt;ReadOnlyMemory&lt;byte&gt;&gt;&gt;(encode.Error!);&#10;                }&#10;&#10;                return Ok(Response&lt;ReadOnlyMemory&lt;byte&gt;&gt;.Create(new ReadOnlyMemory&lt;byte&gt;(encode.Value), responseMeta));&#10;            });&#10;        });&#10;    }&#10;}&#10;&#10;internal sealed class CheckoutWorkflow&#10;{&#10;    private readonly UnaryClient&lt;ReserveSkuRequest, ReserveSkuResponse&gt; _inventoryClient;&#10;    private readonly OnewayClient&lt;AuditRecord&gt; _auditClient;&#10;    private readonly JsonCodec&lt;AuditRecord, object&gt; _auditCodec;&#10;    private readonly string _inventoryEncoding;&#10;    private readonly ILogger&lt;CheckoutWorkflow&gt; _logger;&#10;&#10;    public CheckoutWorkflow(OmniDispatcher dispatcher, ILogger&lt;CheckoutWorkflow&gt; logger)&#10;    {&#10;        _logger = logger;&#10;&#10;        var inventoryCodec = new ProtobufCodec&lt;ReserveSkuRequest, ReserveSkuResponse&gt;();&#10;        dispatcher.Codecs.RegisterOutbound(&#10;            &quot;inventory&quot;,&#10;            &quot;inventory::reserve&quot;,&#10;            ProcedureKind.Unary,&#10;            inventoryCodec);&#10;        _inventoryClient = dispatcher.CreateUnaryClient(&quot;inventory&quot;, inventoryCodec);&#10;        _inventoryEncoding = inventoryCodec.Encoding;&#10;&#10;        _auditCodec = new JsonCodec&lt;AuditRecord, object&gt;();&#10;        dispatcher.Codecs.RegisterOutbound(&#10;            &quot;audit&quot;,&#10;            &quot;audit::record&quot;,&#10;            ProcedureKind.Oneway,&#10;            _auditCodec);&#10;        _auditClient = dispatcher.CreateOnewayClient(&quot;audit&quot;, _auditCodec);&#10;    }&#10;&#10;    public async ValueTask&lt;CheckoutResponse&gt; ExecuteAsync(CheckoutRequest request, CancellationToken cancellationToken)&#10;    {&#10;        var reserveRequest = new ReserveSkuRequest&#10;        {&#10;            Sku = request.Sku,&#10;            Quantity = request.Quantity,&#10;            CorrelationId = request.OrderId&#10;        };&#10;&#10;        var inventoryMeta = new RequestMeta(&#10;            service: &quot;inventory&quot;,&#10;            procedure: &quot;inventory::reserve&quot;,&#10;            caller: &quot;gateway.checkout&quot;,&#10;            encoding: _inventoryEncoding);&#10;&#10;        var inventoryCall = await _inventoryClient.CallAsync(&#10;            new Request&lt;ReserveSkuRequest&gt;(inventoryMeta, reserveRequest),&#10;            cancellationToken).ConfigureAwait(false);&#10;&#10;        if (inventoryCall.IsFailure)&#10;        {&#10;            _logger.LogWarning(&#10;                &quot;Inventory reserve failed for {OrderId}: {Message}&quot;,&#10;                request.OrderId,&#10;                inventoryCall.Error?.Message ?? &quot;unknown&quot;);&#10;&#10;            await PublishAuditAsync(&#10;                request.OrderId,&#10;                &quot;inventory.error&quot;,&#10;                inventoryCall.Error?.Message ?? &quot;inventory call failed&quot;,&#10;                cancellationToken).ConfigureAwait(false);&#10;&#10;            return new CheckoutResponse(&#10;                request.OrderId,&#10;                false,&#10;                ConfirmationId: string.Empty,&#10;                Message: inventoryCall.Error?.Message ?? &quot;Inventory error&quot;);&#10;        }&#10;&#10;        var reserveResponse = inventoryCall.Value.Body;&#10;        var message = reserveResponse.Success&#10;            ? $&quot;Reserved {request.Quantity} units of {request.Sku}&quot;&#10;            : string.IsNullOrWhiteSpace(reserveResponse.Message)&#10;                ? &quot;Inventory declined reservation.&quot;&#10;                : reserveResponse.Message;&#10;&#10;        await PublishAuditAsync(&#10;            request.OrderId,&#10;            reserveResponse.Success ? &quot;inventory.success&quot; : &quot;inventory.reject&quot;,&#10;            message,&#10;            cancellationToken).ConfigureAwait(false);&#10;&#10;        return new CheckoutResponse(&#10;            request.OrderId,&#10;            reserveResponse.Success,&#10;            reserveResponse.ConfirmationId,&#10;            message);&#10;    }&#10;&#10;    private async ValueTask PublishAuditAsync(string orderId, string eventType, string details, CancellationToken cancellationToken)&#10;    {&#10;        var meta = new RequestMeta(&#10;            service: &quot;audit&quot;,&#10;            procedure: &quot;audit::record&quot;,&#10;            caller: &quot;gateway.checkout&quot;,&#10;            encoding: _auditCodec.Encoding);&#10;&#10;        var record = new AuditRecord(orderId, eventType, details, DateTimeOffset.UtcNow);&#10;        var ack = await _auditClient.CallAsync(new Request&lt;AuditRecord&gt;(meta, record), cancellationToken).ConfigureAwait(false);&#10;        if (ack.IsFailure)&#10;        {&#10;            _logger.LogWarning(&quot;Audit publishing failed for {OrderId}: {Message}&quot;, orderId, ack.Error?.Message ?? &quot;unknown&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>